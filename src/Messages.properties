
234tree = 2-3-4 tree

23tree = 2-3 tree

EMPTYSTR = \ 

aaok = This node is OK.

aaskew = Skew: Left subtree has the same rank; we perform a right rotation.

aaskew2 = Skew2: Left subtree has the same rank; we perform a right rotation.

aaskew3 = Skew3: Left subtree has the same rank; we perform a right rotation.

aasplit = Split: The pseudonode (nodes of equal rank) is too big; we perform a left rotation and promote the middle node.

aasplit2 = Split2: The pseudonode (nodes of equal rank) is too big; we perform a left rotation and promote the middle node.

aatree = AA tree

activeheap = Active heap:

alreadythere = The key is already in the tree.

avedepth = Ave. depth

avldeletebal = Node has been deleted. We go back and update the balance information.

avlinsertbal = Node has been inserted. We go back and update the balance information.

avll = The right subtree is too high: We perform a left rotation.

avllr = The left subtree is too high, but its right subtree is higher that the left one: We perform a left-right rotation.

avlr = The left subtree is too high: We perform a right rotation.

avlrl = The right subtree is too high, but its left subtree is higher than the right one: We perform a right-left rotation.

avltree = AVL tree

avlupdatebal = We update the balance information.

bdelete1 = Case I: The key is in a leaf; we can delete it.

bdelete2 = Case II: The key is in an internal node; we replace it by its successor.

bfind = #1 &lt; #2 &lt; #3, we go along the #4. link.

bfind0 = #1 &lt; #2, we go along the 1. link.

bfindn = #1 &lt; #2, we go along the #3. link.

binheap = Binomial heap

binsertleaf = We insert the key into this node.

bleft = Case I: The node is too small, but its left brother is big enough so we can take one key from it.

bmerge = Case III: The node is too small and so is its brother, so we merge them.

bright = Case II: The node is too small, but its right brother is big enough so we can take one key from it.

bsplit = The node is too big, we have to split it.

bst = Binary search tree

bstdeletecase1 = Case I: The node is a leaf; we can delete it.

bstdeletecase2 = Case II: The node has one son; we link the son to node's father and then delete it.

bstdeletecase3 = Case III: The node has two sons; we find it's successor which will replace it. (Successor is the leftmost node in the right subtree - this has at most one son and we can delete it easily.)

bstdeletestart = First we have to find the node.

bstfindleft = Since #1 &lt; #2, we search the left subtree.

bstfindright = Since #1 &gt; #2, we search the right subtree.

bstfindstart = We start searching at the root.

bstinsertleft = Since #1 &lt; #2, we insert it in the left subtree.

bstinsertright = Since #1 &gt; #2, we insert it in the right subtree.

bstinsertstart = We start at the root.

btree = B tree

btreeorder = Order of the B Tree:

button-clear = Clear

button-decreasekey = Decrease key

button-delete = Delete

button-deletemax = Delete Maximum

button-deletemin = Delete Minimum

button-increasekey = Increase key

button-insert = Insert

button-makeset = Add elements

button-meld = Meld

button-pause = Pause

button-random = Random

button-snapshot = Snapshot

button-random-unions = Random unions

button-save = Save

button-uffind = Find

button-union = Union

control = Control

datastructures = Data structures

decreasekey = Decrease key

deleted = Deleted

deletion = Deletion

dictionary = Dictionaries

display = Display

done = That's it.

empty = The tree is empty.

emptyheap = heap is empty

excess = Excess nodes

fibheap = Fibonacci heap

find = Find

found = Found.

full = full

fullheap = heap is full

gbdeletedeleted = The node has been already deleted.

gbdeletemark = We mark the node for deletion (we will delete when we rebuild the subtree).

gbdeleterebuild = Half of the nodes has been marked for deletion. We rebuild the whole tree.

gbfinddeleted = The node has been deleted. Not found.

gbinsertunmark = The key is already in the tree but marked as deleted. We just unmark it.

gbrebuild1 = Phase I: We transform the subtree into a linear list and delete the nodes marked for deletion.

gbrebuild2 = Phase II: We transform the list into a perfectly balanced tree.

gbtoohigh = This subtree is too high. We rebuild the whole subtree.

heap = Heap

heapempty = The heap is empty.

heapfull = The heap is full.

height = Height

increasekey = Increase key

insertion = Insertion

keys = Keys

language = Language

layout = Layout 

layout-compact = Compact

layout-simple = Simple

lazybinheap = Lazy binomial heap

max = max

maxheap = Max Heap

maxheapbubbledown = We bubble the node down (swap it with its greater child) until it is greater than both of its children.

maxheapbubbleup = We bubble the node up (swap it with its parent) until its parent has greater priority.

meldable-pq = Meldable priority queues

min = min

minheap = Min Heap

minheapbubbledown = We bubble the node down (swap it with its smaller child) until it is smaller than both of its children.

minheapbubbleup = We bubble the node up (swap it with its parent) until its parent has smaller priority.

mode23 = 2-3 tree correspondence

mode234 = 2-3-4 tree correspondence

newroot = The tree is empty so we make a new root.

next = Next

nodes = Nodes

notfound = Not found.

opt = opt

pq = Priority queues

previous = Previous

rbdelete1 = Case I: Node's sibling is red: We recolor some nodes and transform it to Case II, III, or IV.

rbdelete2 = Case II: Node's sibling and both his children are black: the extra black is moved up the tree.

rbdelete3 = Case III: Node's sibling is black, the closer child is red, the next one is black: We transform it to Case IV.

rbdelete4 = Case IV: Node's sibling and his child closer to us is black, the other one is red: By some recoloring and one rotation we can remove the extra black.

rbinsertcase1 = Case I, red uncle: We color the father and uncle black, the grandfather red and continue from grandfather.

rbinsertcase2 = Case II, black uncle, "inner" vertex: We transform this to Case III.

rbinsertcase3 = Case III, black uncle "outer" vertex: We perform a rotation and recolor the nodes.

redblack = Red-black tree

rotate = Rotate

rotations = Rotations

scapegoat = Scapegoat tree

search = Search

show-order = Show order

show-subtrees = Show subtrees

size = Size

skipdelete = Now we delete the node from each level.

skipdown = Next key is greater or equal. We go down.

skipend = We toss a coin. It came up tails so we stop.

skipfindstart = We start searching at the top left corner.

skipinsertafter = We insert the new node right after this one.

skipinsertnext = Next key is less than our key. We insert it right.

skipinsertstart = We start at the top left corner and find appropriate place to insert the new node.

skiplist = Skiplist

skipnext = Next key is less than our key. We go right.

skippromote = We toss a coin. It came up heads so we promote the node.

splay = Splay

splaydelete = We delete the root, splay the right subtree for minimum.

splaydeleteleft = The root has no right subtree; we just delete it and make the left child the new root.

splaydeletelink = The minimum of the right tree will be the new root; since minimum has no left son, we can just link the left tree.

splaydeleteright = The root has no left subtree; we just delete it and make the right child the new root.

splayfound = We splay this node.

splayinroot = Now our key, smallest bigger or biggest smaller is in the root.

splayinsertleft = Now the root and its left subtree is less than our key and root's right subtree is greater than our key: we just make a new root and link the current root left and it's right subtree right.

splayinsertright = Now the root and its right subtree is greater than our key and root's left subtree is less than our key: we just make a new root and link the current root right and it's left subtree left.

splayroot = There is no grandparent; we just rotate.

splaystart = First we find the key or the smallest bigger key or the biggest smaller key and splay it to the root.

splaytree = Splay tree

splayzigzagleft = Zig-zag case (parent is to the right and grandparent to the left): we rotate the node twice.

splayzigzagright = Zig-zag case (parent is to the left and grandparent to the right): we rotate the node twice.

splayzigzigleft = Zig-zig case (parent and grandparent are to the right): we first rotate the parent and then the node.

splayzigzigright = Zig-zig case (parent and grandparent are to the left): we first rotate the parent and then the node.

text = Text

treap = Treap

treapbubbledown = We bubble the node down.

treapbubbleup = We bubble the node up until its parent has greater priority.

treapdeletecase1 = Now the node is a leaf and we can simply delete it.

uf-byrank = by rank

uf-compresion = path compression

uf-find-heuristic = Find:

uf-halving = path halving

uf-none = na\u00EFve

uf-splitting = path splitting

uf-union-heuristic = Union:

ufa = Union Find

ufalreadyroot = This node is a representative!

ufcompression = Let's compress the marked path.

ufdown = We are going down.

ufdownson = A son of a representative is linked already.

ufdownstart = We go back and link all elements to the representative. 

uffind = Find a representative

uffindstart = We start searching for representative of set containing element #1.

ufi = Union Find

ufrootfound = We have found a representative of the set. It is: #1.

ufsameset = Elements are in the same set, no linking needed.

ufunion = Union

ufunionbyrank = First representative has a rank: #1, second one has a rank: #2. Lesser rank decides.

ufunionfirstsecond = Therefore, we link second representative to first one.

ufunionsamerank = Both representatives have the same rank. So, we choose by default to link the second one under the first one. Increment rank of the first representative by 1.

ufunionsecondfirst = Therefore, we link first representative to  second one.

ufunionsimple = Link second representative to first one.\u0009

ufup = Moving toward to root.

ufupspecial = We link grandchild.

zoomio = Zoom in/out
