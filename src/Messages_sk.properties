#Generated by ResourceBundle Editor (http://eclipse-rbe.sourceforge.net)
#-------------------------------------------------------------------------------
# Copyright (c) 2012 Jakub Kovac, Katarina Kotrlova, Pavol Lukca, Viktor Tomkovic, Tatiana Tothova
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#-------------------------------------------------------------------------------

234tree = 2-3-4 strom

23tree = 2-3 strom

EMPTYSTR = \ 

aaok = Tento vrchol je OK.

aaskew = Skew: \u013Dav\u00FD podstrom m\u00E1 rovnak\u00FD rank; sprav\u00EDme rot\u00E1ciu doprava.

aaskew2 = Skew2: \u013Dav\u00FD podstrom m\u00E1 rovnak\u00FD rank; sprav\u00EDme rot\u00E1ciu doprava.

aaskew3 = Skew3: \u013Dav\u00FD podstrom m\u00E1 rovnak\u00FD rank; sprav\u00EDme rot\u00E1ciu doprava.

aasplit = Split: Pseudovrchol (tvoren\u00FD susedn\u00FDmi vrcholmi s rovnak\u00FDm rankom) je pr\u00EDli\u017E ve\u013Ek\u00FD; sprav\u00EDme rot\u00E1ciu v\u013Eavo a zv\u00FD\u0161ime rank stredn\u00E9ho vrcholu.

aasplit2 = Split2: Pseudovrchol (tvoren\u00FD susedn\u00FDmi vrcholmi s rovnak\u00FDm rankom) je pr\u00EDli\u017E ve\u013Ek\u00FD; sprav\u00EDme rot\u00E1ciu v\u013Eavo a zv\u00FD\u0161ime rank stredn\u00E9ho vrcholu.

aatree = AA strom

activeheap = Akt\u00EDvna halda:

alreadythere = Dan\u00FD k\u013E\u00FA\u010D sa u\u017E nach\u00E1dza v strome.

avedepth = Priem. h\u013Abka

avldeletebal = Pr\u00E1ve sme vymazali vrchol; vraciame sa sp\u00E4\u0165 ku kore\u0148u a upravujeme inform\u00E1cie o vyv\u00E1\u017Eenosti.

avlinsertbal = Pr\u00E1ve sme vlo\u017Eili nov\u00FD vrchol; vraciame sa sp\u00E4\u0165 ku kore\u0148u a upravujeme inform\u00E1cie o vyv\u00E1\u017Eenosti.

avll = Prav\u00FD podstrom je pr\u00EDli\u0161 vysok\u00FD: rotujeme do\u013Eava.

avllr = Prav\u00FD podstrom je pr\u00EDli\u0161 vysok\u00FD, ale jeho \u013Eav\u00FD podstrom je vy\u0161\u0161\u00ED ako prav\u00FD: rotujeme najsk\u00F4r do\u013Eava, potom doprava.

avlr = \u013Dav\u00FD podstrom je pr\u00EDli\u0161 vysok\u00FD: rotujeme doprava.

avlrl = \u013Dav\u00FD podstrom je pr\u00EDli\u0161 vysok\u00FD, ale jeho prav\u00FD podstrom je vy\u0161\u0161\u00ED ako \u013Eav\u00FD: rotujeme najsk\u00F4r doprava, potom do\u013Eava.

avltree = AVL strom

avlupdatebal = Uprav\u00EDme inform\u00E1ciu o vyv\u00E1\u017Eenosti.

badword = Zadali ste neplatn\u00E9 slovo. Pros\u00EDm, vkladajte slov\u00E1 zlo\u017Een\u00E9 len z mal\u00FDch a ve\u013Ek\u00FDch p\u00EDsmen anglickej abecedy. Mal\u00E9 p\u00EDsmen\u00E1 bud\u00FA preveden\u00E9 na ve\u013Ek\u00E9.

bdelete1 = Pr\u00EDpad I: K\u013E\u00FA\u010D je v liste, m\u00F4\u017Eeme ho odstr\u00E1ni\u0165.

bdelete2 = Pr\u00EDpad II: K\u013E\u00FA\u010D je v internom vrchole; nahrad\u00EDme ho jeho nasledovn\u00EDkom.

bfind = #1 &lt; #2 &lt; #3, ideme po #4. hrane.

bfind0 = #1 &lt; #2, ideme po 1. hrane.

bfindn = #1 &lt; #2, ideme po #3. hrane.

binheap = Binomi\u00E1lna halda

binheap-add-tree = Prid\u00E1me \u010Fal\u0161\u00ED strom.

binheap-bottom-empty = Spodn\u00E1 halda je pr\u00E1zdna a sp\u00E1janie je trivi\u00E1lne.

binheap-findmax = Odstr\u00E1nime minimum a n\u00E1jdeme nov\u00E9 - to je ur\u010Dite kore\u0148 niektor\u00E9ho stromu.

binheap-findmin = Odstr\u00E1nime minimum a n\u00E1jdeme nov\u00E9 - to je ur\u010Dite kore\u0148 niektor\u00E9ho stromu.

binheap-insert = Vlo\u017Eenie vrcholu do haldy je to ist\u00E9 ako zl\u00FA\u010Denie s 1-prvkovou haldou.

binheap-link = Stromy #1 a #2 s\u00FA rovnak\u00E9ho r\u00E1du, tak\u017Ee ich spoj\u00EDme (#1 bude syn #2).

binheap-meld-idea = Postupne prid\u00E1vame stromy zo spodnej haldy, pri\u010Dom dva binomi\u00E1lne stromy rovnak\u00E9ho r\u00E1du v\u017Edy spoj\u00EDme do jedn\u00E9ho s vy\u0161\u0161\u00EDm r\u00E1dom.

binheap-meldchildren = Deti vymazan\u00E9ho vrcholu tvoria op\u00E4\u0165 binomi\u00E1lnu haldu, ktor\u00FA zl\u00FA\u010Dime s p\u00F4vodnou.

binheap-newmax = Nov\u00E9 maximum je #1.

binheap-newmin = Nov\u00E9 minimum je #1.

binheap-next = Prejdeme na \u010Fal\u0161\u00ED vrchol.

binheap-nochildren = Vymazan\u00FD vrchol nemal \u017Eiadne deti.

binheap-oldmax = #1 ost\u00E1va najv\u00E4\u010D\u0161\u00EDm prvkom.

binheap-oldmin = #1 ost\u00E1va najmen\u0161\u00EDm prvkom.

binheap-top-empty = Horn\u00E1 halda je pr\u00E1zdna a sp\u00E1janie je trivi\u00E1lne.

binsertleaf = K\u013E\u00FA\u010D vlo\u017E\u00EDme do tohto vrcholu.

bleft = Pr\u00EDpad I: Vrchol je pr\u00EDli\u017E mal\u00FD, ale jeho \u013Eav\u00FD brat je dos\u0165 ve\u013Ek\u00FD, tak\u017Ee si od neho m\u00F4\u017Eeme jeden k\u013E\u00FA\u010D zobra\u0165.

bmerge = Pr\u00EDpad III: Vrchol aj jeho bratia s\u00FA pr\u00EDli\u017E mal\u00ED, tak\u017Ee ich spoj\u00EDme.

bright = Pr\u00EDpad II: Vrchol je pr\u00EDli\u017E mal\u00FD, ale jeho prav\u00FD brat je dos\u0165 ve\u013Ek\u00FD, tak\u017Ee si od neho m\u00F4\u017Eeme jeden k\u013E\u00FA\u010D zobra\u0165.

bsplit = Vrchol je pr\u00EDli\u017E ve\u013Ek\u00FD, mus\u00EDme ho rozdeli\u0165.

bst = Bin\u00E1rny vyh\u013Ead\u00E1vac\u00ED strom

bst-delete-case1 = Pr\u00EDpad I: Vrchol je list, tak\u017Ee ho m\u00F4\u017Eeme jednoducho odstr\u00E1ni\u0165.

bst-delete-case2 = Pr\u00EDpad II: Vrchol m\u00E1 iba jedn\u00E9ho syna.

bst-delete-case3 = Pr\u00EDpad III: Vrchol #1 m\u00E1 oboch synov. V tomto pr\u00EDpade n\u00E1jdeme jeho nasledovn\u00EDka, ktor\u00FDm ho nahrad\u00EDme. Nasledovn\u00EDk je naj\u013Eavej\u0161\u00ED vrchol v pravom podstrome. M\u00E1 najviac jedn\u00E9ho syna (prav\u00E9ho) a teda ho vieme jednoducho odstr\u00E1ni\u0165.

bst-delete-go-left = Cho\u010F v\u013Eavo.

bst-delete-linkpar = Vrchol #1 odstr\u00E1nime, pri\u010Dom #2 zaves\u00EDme pod jeho star\u00E9ho otca #3.

bst-delete-newroot = Vrchol #1 odstr\u00E1nime. Jeho syn #2 sa stane nov\u00FDm kore\u0148om.

bst-delete-replace = Vrchol #1 vymen\u00EDme za #2 a #1 odstr\u00E1nime.

bst-delete-succ = Vrchol #2 je nasledovn\u00EDkom #1 (\u017Eiadny prvok v strome nie je medzi #1 a #2). Ke\u010F\u017Ee #2 nem\u00E1 \u013Eav\u00E9ho syna, vieme ju jednoducho odpoji\u0165.

bst-delete-succ-link = Odpoj\u00EDme nasledovn\u00EDka, pri\u010Dom vrchol #1 napoj\u00EDme pod #2.

bst-delete-succ-start = Za\u010Dneme v koreni prav\u00E9ho podstromu.

bst-delete-succ-unlink = Nasledovn\u00EDka jednoducho odpoj\u00EDme.

bst-delete-unlink = Vrchol jednoducho odpoj\u00EDme.

bst-insert-left = Ke\u010F\u017Ee #1 &lt; #2, vklad\u00E1me do \u013Eav\u00E9ho podstromu.

bst-insert-right = Ke\u010F\u017Ee #1 &gt; #2, vklad\u00E1me do prav\u00E9ho podstromu.

bst-insert-start = Za\u010Dneme v koreni.

bstdeletestart = Najsk\u00F4r mus\u00EDme n\u00E1js\u0165 vrchol s dan\u00FDm k\u013E\u00FA\u010Dom.

bstfindleft = Ke\u010F\u017Ee #1 &lt; #2, h\u013Ead\u00E1me v \u013Eavom podstrome.

bstfindright = Ke\u010F\u017Ee #1 &gt; #2, h\u013Ead\u00E1me v pravom podstrome.

bstfindstart = Za\u010Dneme h\u013Eada\u0165 v koreni.

btree = B strom

btreeorder = R\u00E1d B stromu:

button-changekey = Zme\u0148 k\u013E\u00FA\u010D

button-clear = Zma\u017E

button-create-st = Vytvor sufixov\u00FD strom

button-decreasekey = Zn\u00ED\u017E hodnotu

button-delete = Odstr\u00E1\u0148

button-deletemax = Odstr\u00E1\u0148 maximum

button-deletemin = Odstr\u00E1\u0148 minimum

button-find = H\u013Eadaj

button-findmax = N\u00E1jdi max intervalu

button-findmin = N\u00E1jdi min intervalu

button-findsum = N\u00E1jdi s\u00FA\u010Det intervalu

button-increasekey = Zv\u00FD\u0161 hodnotu

button-insert = Vlo\u017E

button-makeset = Pridaj prvky

button-meld = Zl\u00FA\u010D

button-pause = Pauzy

button-random = N\u00E1hodn\u00E9

button-random-unions = Spoj n\u00E1hodn\u00E9 prvky

button-rotate = Rotuj

button-save = Ulo\u017Ei\u0165

button-uffind = N\u00E1jdi

button-union = Spoj

changekey = Zmena hodnoty

changekeyv = Zmen\u00EDme hodnotu k\u013E\u00FA\u010Da.

control = Ovl\u00E1danie

daryheap = d-\u00E1rna halda

daryheaporder = R\u00E1d d-n\u00E1rnej haldy

datastructures = D\u00E1tov\u00E9 \u0161trukt\u00FAry

decreasekey = Zn\u00ED\u017Eenie hodnoty

decrkeymin = Zn\u00ED\u017Eime hodnotu k\u013E\u00FA\u010Da

delete = Odstr\u00E1\u0148 #1

delete-max = Odstr\u00E1\u0148 maximum

delete-min = Odstr\u00E1\u0148 minimum

deleted = Vymazan\u00FDch

dictionary = Slovn\u00EDky

display = Display

done = Hotovo.

empty = Strom je pr\u00E1zdny.

emptyheap = pr\u00E1zdna halda

excess = Vrcholov navy\u0161e

fibheap = Fibonacciho halda

find = H\u013Eadaj #1

findmax = N\u00E1jdi maximum z intervalu &lang;#1,#2&rang;

findmin = N\u00E1jdi minimum z intervalu &lang;#1,#2&rang;

findsum = N\u00E1jdi s\u00FA\u010Det intervalu &lang;#1,#2&rang;

found = N\u00E1jden\u00E9.

full = pln\u00E9

fullheap = pln\u00E1

gbdeletedeleted = Vrchol u\u017E je ozna\u010Den\u00FD na vymazanie.

gbdeletemark = Vrchol ozna\u010D\u00EDme na vymazanie (naozaj ho odstr\u00E1nime a\u017E pri najbli\u017E\u0161om prebudovan\u00ED stromu).

gbdeleterebuild = Polovica vrcholov u\u017E je ozna\u010Den\u00E1 na vymazanie. Cel\u00FD strom prebudujeme.

gbfinddeleted = Vrchol je ozna\u010Den\u00FD na vymazanie. Nen\u00E1jden\u00E9.

gbinsertunmark = K\u013E\u00FA\u010D u\u017E je v strome, ale ozna\u010Den\u00FD na vymazanie. Iba zru\u0161\u00EDme zna\u010Dku.

gbrebuild1 = F\u00E1za I: Transformujeme podstrom na "prav\u00FA re\u0165az" a odstra\u0148ujeme vrcholy ozna\u010Den\u00E9 na vymazanie.

gbrebuild2 = F\u00E1za II: Re\u0165az transformujeme na dokonale vyv\u00E1\u017Een\u00FD strom.

gbtoohigh = Tento podstrom je pr\u00EDli\u0161 vysok\u00FD, cel\u00FD ho prebudujeme.

heap = Halda

heap-last = Toto je posledn\u00FD vrchol, v\u00FDsledn\u00E1 halda je pr\u00E1zdna.

heapchange = Kore\u0148 vymen\u00EDme s posledn\u00FDm vrcholom a ten n\u00E1sledne odstr\u00E1nime.

heapempty = Halda je pr\u00E1zdna.

heapfull = Halda je pln\u00E1.

height = V\u00FD\u0161ka

implicit = Zobraz implicitn\u00E9 vrcholy

increasekey = Zv\u00FD\u0161enie hodnoty

incrkeymax = Zv\u00FD\u0161\u00EDme hodnotu k\u013E\u00FA\u010Da.

insert = Vlo\u017E #1

intervalchangev = Ak zmen\u00EDme hodnotu k\u013E\u00FA\u010Da v liste, mus\u00EDme upravi\u0165 hodnoty v\u0161etk\u00FDch vrcholov na ceste z tohto vrchola do kore\u0148a.

intervalempty = Interval &lang;#1,#2&rang;, ktor\u00FD reprezentuje tento vrchol je pr\u00E1zdny.

intervalextend = Ke\u010F\u017Ee po\u010Det prvkov v poli dosiahol po\u010Det listov, mus\u00EDme strom roz\u0161\u00EDri\u0165.

intervalfind = M\u00F4\u017Eu nasta\u0165 tri pr\u00EDpady vz\u00E1jomnej polohy intervalu, ktor\u00FD reprezentuje vrchol moment\u00E1lne uva\u017Eovan\u00FD DFS (a) a intervalu, ktor\u00FD h\u013Ead\u00E1me (b). \r\n<br/>1. Nepret\u00EDnaj\u00FA sa - v preh\u013Ead\u00E1van\u00ED vynech\u00E1me podstrom zakorenen\u00FD v tomto vrchole. \r\n<br/>2. Pret\u00EDnaj\u00FA sa ale interval (a) nie je vnoren\u00FD do intervalu (b) - pokra\u010Dujeme v preh\u013Ead\u00E1van\u00ED v podstrome. \r\n<br/>3. Interval (a) je vnoren\u00FD do intervalu (b) - na\u0161li sme vrchol, ktor\u00FD reprezentuje \u010Das\u0165 intervalu, ktor\u00FD h\u013Ead\u00E1me, tak\u017Ee nepokra\u010Dujeme v h\u013Eadan\u00ED v podstrome.

intervalin = Interval &lang;#4,#5&rang;, ktor\u00FD reprezentuje vrchol #3 je vnoren\u00FD do intervalu &lang;#1,#2&rang;.

intervalinsert = Ak prid\u00E1me nov\u00FD prvok, mus\u00EDme upravi\u0165 hodnoty v\u0161etk\u00FDch vrcholov na ceste z tohto vrchola do kore\u0148a.

intervalkeyempty = Ke\u010F\u017Ee prav\u00FD syn je pr\u00E1zdny, vyberieme k\u013E\u00FA\u010D \u013Eav\u00E9ho syna.

intervalmax = Vyberieme v\u00E4\u010D\u0161\u00ED k\u013E\u00FA\u010D z #2 a #1.

intervalmin = Vyberieme men\u0161\u00ED k\u013E\u00FA\u010D z #1 a #2.

intervalout = Interval &lang;#4,#5&rang;, ktor\u00FD reprezentuje vrchol #3 je mimo intervalu &lang;#1,#2&rang;.

intervalpart = Interval &lang;#4,#5&rang;, ktor\u00FD reprezentuje vrchol #3 nie je vnoren\u00FD do intervalu &lang;#1,#2&rang;, ale maj\u00FA nepr\u00E1zdny prienik.

intervalsum = Vo vrchole bude s\u00FA\u010Det k\u013E\u00FA\u010Dov \u013Eav\u00E9ho a prav\u00E9ho syna.

intervaltree = Intervalov\u00FD strom

intervaltrees = Intervalov\u00E9 stromy

keys = K\u013E\u00FA\u010Dov

language = Language

layout = Layout

layout-compact = Kompaktn\u00FD

layout-simple = Jednoduch\u00FD

lazybinheap = Leniv\u00E1 binomi\u00E1lna halda

leftheap = \u013Davicov\u00E1 halda

leftinsertright = Ke\u010F\u017Ee #1 &gt; #2, vklad\u00E1me do prav\u00E9ho podstromu.

leftinsertup = Ke\u010F\u017Ee #1 &le; #2, z #2 sa stane prav\u00FD syn #1.

leftmeldnoson = Ke\u010F\u017Ee #2 nem\u00E1 prav\u00E9ho syna, pripoj\u00EDme zvy\u0161ok ako prav\u00E9ho syna #2.

leftmeldrightg = Ke\u010F\u017Ee #1 &gt; #2, ni\u010D sa nestane a pokra\u010Dujeme v porovn\u00E1van\u00ED po pravej ceste.

leftmeldrightl = Ke\u010F\u017Ee #1 &lt; #2, ni\u010D sa nestane a pokra\u010Dujeme v porovn\u00E1van\u00ED po pravej ceste.

leftmeldstart = Za\u010Dneme porovnan\u00EDm prv\u00FDch prvkov pravej cesty, teda kore\u0148ov.

leftmeldswapg = Ke\u010F\u017Ee #1 &ge; #2, vymen\u00EDme haldy a pokra\u010Dujeme v porovn\u00E1van\u00ED po pravej ceste.

leftmeldswapl = Ke\u010F\u017Ee #1 &le; #2, vymen\u00EDme haldy a pokra\u010Dujeme v porovn\u00E1van\u00ED po pravej ceste.

leftrankstart = Povymie\u0148ame \u013Eav\u00FDch a prav\u00FDch synov pod\u013Ea ranku. Ak je rank prav\u00E9ho syna v\u00E4\u010D\u0161\u00ED ako rank \u013Eav\u00E9ho syna, vymen\u00EDme ich, inak sa ni\u010D nestane.

leftrankupdate = Uprav\u00EDme ranky.

lipsum = Slovensky lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut commodo, neque id accumsan imperdiet, metus felis pharetra est, nec molestie diam elit a lectus. Maecenas erat purus, tempor nec aliquam id, tincidunt vel dui. Cras fermentum suscipit porta. 

max = max

maxdheapbubbledown = Prebubleme vrchol nadol (vymie\u0148ame v\u017Edy s najv\u00E4\u010D\u0161\u00EDm synom, k\u00FDm nemaj\u00FA v\u0161etci synovia men\u0161iu prioritu). 

maxheap = Max Halda

maxheapbubbledown = Prebubleme vrchol nadol (vymie\u0148ame v\u017Edy s v\u00E4\u010D\u0161\u00EDm synom, k\u00FDm nemaj\u00FA obaja synovia men\u0161iu prioritu).

maxheapbubbleup = Prebubleme vrchol nahor (t.j. vymie\u0148ame s otcom, k\u00FDm nem\u00E1 otec v\u00E4\u010D\u0161iu prioritu).

maximum = Maximum je  #1.

meld = Zl\u00FA\u010D haldy ###1 a ###2

meldable-pq = Zl\u00FA\u010Dite\u013En\u00E9 prioritn\u00E9 fronty

min = min

mindheapbubbledown = Prebubleme vrchol nadol (vymie\u0148ame v\u017Edy s najmen\u0161\u00EDm synom, k\u00FDm nemaj\u00FA v\u0161etci synovia v\u00E4\u010D\u0161iu prioritu). 

minheap = Min Halda

minheapbubbledown = Prebubleme vrchol nadol (vymie\u0148ame v\u017Edy s men\u0161\u00EDm synom, k\u00FDm nemaj\u00FA obaja synovia v\u00E4\u010D\u0161iu prioritu).

minheapbubbleup = Prebubleme vrchol nahor (t.j. vymie\u0148ame s otcom, k\u00FDm nem\u00E1 otec men\u0161iu prioritu).

minimum = Minimum je  #1.

mode23 = S\u00FAvis s 2-3 stromami

mode234 = S\u00FAvis s 2-3-4 stromami

newroot = Ke\u010F\u017Ee je strom pr\u00E1zdny, vytvor\u00EDme nov\u00FD kore\u0148.

next = \u010Ealej

nodes = Vrcholov

notfound = Nen\u00E1jden\u00E9.

opt = opt

pairdecr = Po zn\u00ED\u017Een\u00ED hodnoty sa mohla pokazi\u0165 vlastnos\u0165 haldy, preto vrchol odtrhneme a znovu prilinkujeme.

pairincr = Po zv\u00FD\u0161en\u00ED hodnoty sa mohla pokazi\u0165 vlastnos\u0165 haldy, preto vrchol odtrhneme a znovu prilinkujeme.

pairing = P\u00E1rovanie

pairingbf = zozadu dopredu

pairingfb = spredu dozadu

pairingheap = P\u00E1rovacia halda

pairinglazymulti = leniv\u00E9 viacprechodov\u00E9

pairinglrrl = z\u013Eava doprava sprava do\u013Eava

pairingmultipass = viacprechodov\u00E9

pairingnaive = naivn\u00E9

pairlinkmax = Ke\u010F\u017Ee #1 &lt; #2, pripoj\u00EDme #1 ku #2.

pairlinkmin = Ke\u010F\u017Ee #1 &lt; #2, pripoj\u00EDme #2 ku #1.

pairlrrl1 = Ak si zvol\u00EDme pr\u00EDstup "z\u013Eava doprava sprava do\u013Eava",  najprv z\u013Eava doprava stromy pop\u00E1rujeme. (Prv\u00FD podstrom prilinkujeme k druh\u00E9mu, tret\u00ED ku \u0161tvrt\u00E9mu at\u010F.)

pairlrrl2 = Potom k posledn\u00E9mu podstromu postupne sprava do\u013Eava prilinkujeme zvy\u0161n\u00E9 podstromy.

pairnaive = Ak si zvol\u00EDme "naivn\u00E9" rie\u0161enie, vyberieme jeden z podstromov a postupne k nemu prilinkujeme ostatn\u00E9.

pq = Prioritn\u00E9 fronty

previous = Sp\u00E4\u0165

rbdelete1 = Pr\u00EDpad I: \u010Derven\u00FD s\u00FArodenec: Vymen\u00EDme farby otca a prav\u00E9ho s\u00FArodenca a zrotujeme s\u00FArodenca; dostaneme tak pr\u00EDpad II, III, alebo IV.

rbdelete2 = Pr\u00EDpad II, s\u00FArodenec a obe jeho deti s\u00FA \u010Dierne: the extra black is moved up the tree.

rbdelete3 = Pr\u00EDpad III, s\u00FArodenec a jeho "vonkaj\u0161\u00ED" syn s\u00FA \u010Dierni, jeho "vn\u00FAtorn\u00FD" syn je \u010Derven\u00FD: Prevedieme na pr\u00EDpad IV.

rbdelete4 = Pr\u00EDpad IV, s\u00FArodenec a jeho "vn\u00FAtorn\u00FD" syn s\u00FA \u010Dierni, jeho "vonkaj\u0161\u00ED" syn je \u010Derven\u00FD: Vymen\u00EDme farby otca a s\u00FArodenca, zrotujeme ho a jeho \u010Derven\u00E9ho syna zafarb\u00EDme na \u010Dierno.

rbinsertcase1 = Pr\u00EDpad I, \u010Derven\u00FD str\u00FDko: Prefarb\u00EDme otca a str\u00FDka na \u010Dierno, star\u00E9ho otca na \u010Derveno a pokra\u010Dujeme star\u00FDm otcom.

rbinsertcase2 = Pr\u00EDpad II, \u010Dierny str\u00FDko, "vn\u00FAtorn\u00FD vrchol": prevedieme na pr\u00EDpad III.

rbinsertcase3 = Pr\u00EDpad III, \u010Dierny str\u00FDko, "vonkaj\u0161\u00ED vrchol": Zrotujeme a prefarb\u00EDme vrcholy.

redblack = \u010Cerveno-\u010Dierny strom

rotate = Zrotujeme #1.

rotate-change = Vrcholy #1 a #2 si vymenia \u00FAlohy: #1 sa stane synom #2...

rotate-change-b = ...a #1 sa stane synom #2.

rotate-change-nullb = ...a syn #1 [\u017Eiadny] sa stane synom #2.

rotate-change-parent = ...#1 sa stane otcom #2...

rotate-changes = Vrcholy #1 a #3 si vymenia \u00FAlohy: #1 sa stane nov\u00FDm synom #4 a #3 bude synom #1. Vrcholu #2 sa zmen\u00ED otec (#3 namiesto #1).

rotate-fall = Tento podstrom klesne.

rotate-header = Rotuj #1

rotate-newroot = ...#1 sa stane nov\u00FDm kore\u0148om...

rotate-preserves-order = V\u0161imnite si, \u017Ee rot\u00E1cia zachov\u00E1va poradia vrcholov.

rotate-rise = Tento podstrom st\u00FApne.

rotate-root = Vrchol #1 je kore\u0148; kore\u0148 sa ned\u00E1 zrotova\u0165.

rotations = Rot\u00E1cie

scapegoat = GB strom

search = H\u013Eadanie

show-order = Uk\u00E1\u017E poradie

show-subtrees = Uk\u00E1\u017E podstromy

size = Ve\u013Ekos\u0165

skewheap = Skew halda

skewheapswap = Povymie\u0148ame \u013Eav\u00FDch a prav\u00FDch synov v\u0161etk\u00FDch vrcholov pravej cesty okrem synov posledn\u00E9ho vrcholu.

skipdelete = N\u00E1jden\u00FD vrchol vyma\u017Eeme z ka\u017Edej \u00FArovne.

skipfindstart = Za\u010Dneme h\u013Eada\u0165 v \u013Eavom hornom rohu.

skipinsertafter = Nov\u00FD vrchol vlo\u017E\u00EDme hne\u010F za tento.

skipinsertnext = Nasleduj\u00FAci vrchol je men\u0161\u00ED ako n\u00E1\u0161. Vklad\u00E1me vpravo.

skipinsertstart = Za\u010Dneme v \u013Eavom hornom rohu a n\u00E1jdeme spr\u00E1vne miesto, kam vlo\u017Ei\u0165 nov\u00FD vrchol.

skiplist = Skiplist

skiplist-delete-found = Na\u0161li sme vrchol, ktor\u00FD treba vymaza\u0165.

skiplist-down = Nasledovn\u00FD vrchol je &gt; #1, tak\u017Ee ideme dolu.

skiplist-head = Hod \u010D. #1: HLAVA. Prid\u00E1me \u010Fal\u0161\u00ED vrchol.

skiplist-next = Nasledovn\u00FD vrchol je &le; #1, ideme doprava.

skiplist-tail = Hod \u010D. #1: ZNAK, tak\u017Ee kon\u010D\u00EDme.

skiplist-tossing = Teraz budeme h\u00E1dza\u0165 mincou, a\u017E k\u00FDm n\u00E1m nepadne ZNAK. Za ka\u017Ed\u00FA padnut\u00FA HLAVU, prid\u00E1me vrchol aj o \u00FArove\u0148 vy\u0161\u0161ie, tak\u017Ee v priemere bude na <i>k</i>-tej \u00FArovni 1/2<sup><i>k</i></sup> vrcholov.

splay = Splay-ovanie

splay-found = N\u00E1jden\u00E9. Tento vrchol budeme splayova\u0165.

splay-higher = K\u013E\u00FA\u010D #1 sa v strome nenach\u00E1dza. Namiesto toho vysplayujeme najbli\u017E\u0161\u00ED v\u00E4\u010D\u0161\u00ED k\u013E\u00FA\u010D, #2.

splay-insert-left = V\u0161imnite si teraz, \u017Ee kore\u0148 a cel\u00FD \u013Eav\u00FD podstrom je men\u0161\u00ED ako #1, zatia\u013E\u010Do cel\u00FD prav\u00FD podstrom je v\u00E4\u010D\u0161\u00ED ako #1.

splay-insert-left2 = Z #1 sprav\u00EDme jednoducho nov\u00FD kore\u0148, star\u00FD kore\u0148 pripoj\u00EDme v\u013Eavo a prav\u00FD podstrom vpravo.

splay-insert-right = V\u0161imnite si teraz, \u017Ee kore\u0148 a cel\u00FD prav\u00FD podstrom je v\u00E4\u010D\u0161\u00ED ako #1, zatia\u013E\u010Do cel\u00FD \u013Eav\u00FD podstrom je men\u0161\u00ED ako #1.

splay-insert-right2 = Z #1 sprav\u00EDme jednoducho nov\u00FD kore\u0148, star\u00FD kore\u0148 pripoj\u00EDme vpravo a \u013Eav\u00FD podstrom v\u013Eavo.

splay-lower = K\u013E\u00FA\u010D #1 sa v strome nenach\u00E1dza. Namiesto toho vysplayujeme najbli\u017E\u0161\u00ED men\u0161\u00ED k\u013E\u00FA\u010D, #2.

splay-root = Vrchol nem\u00E1 star\u00E9ho otca; sprav\u00EDme iba jednu rot\u00E1ciu.

splay-start = Najsk\u00F4r n\u00E1jdeme vysplayujeme #1 vysplayujeme ho do kore\u0148a. Ak #1 nie je v strome, vysplayujeme najbli\u017E\u0161\u00ED v\u00E4\u010D\u0161\u00ED alebo najbli\u017E\u0161\u00ED men\u0161\u00ED k\u013E\u00FA\u010D.

splay-zig-zag-left = Pr\u00EDpad "Cik-cak" (#1 je \u013Eav\u00FD syn zatia\u013E\u010Do #2 je prav\u00FD syn): vrchol #1 dvakr\u00E1t zrotujeme.

splay-zig-zag-right = Pr\u00EDpad "Cik-cak" (#1 je prav\u00FD syn zatia\u013E\u010Do #2 je \u013Eav\u00FD syn): vrchol #1 dvakr\u00E1t zrotujeme.

splay-zig-zig-left = Pr\u00EDpad "Cik-cik" (#1 aj #2 s\u00FA \u013Eav\u00FD synovia): najsk\u00F4r zrotujeme #2, potom #1.

splay-zig-zig-right = Pr\u00EDpad "Cik-cik" (#1 aj #2 s\u00FA prav\u00FD synovia): najsk\u00F4r zrotujeme #2, potom #1.

splaydelete = Odstr\u00E1nime kore\u0148 a vysplayujeme minimum prav\u00E9ho podstromu.

splaydeleteleft = Kore\u0148 nem\u00E1 prav\u00E9ho syna; jednoducho ho odstr\u00E1nime a z \u013Eav\u00E9ho syna sprav\u00EDme nov\u00FD kore\u0148.

splaydeletelink = Minimum bude teraz nov\u00FD kore\u0148; ke\u010F\u017Ee minimum nem\u00E1 \u013Eav\u00E9ho syna, sta\u010D\u00ED prilinkova\u0165 \u013Eav\u00FD podstrom k nov\u00E9mu kore\u0148u.

splaydeleteright = Kore\u0148 nem\u00E1 \u013Eav\u00E9ho syna; jednoducho ho odstr\u00E1nime a z prav\u00E9ho syna sprav\u00EDme nov\u00FD kore\u0148.

splayinroot = Teraz je n\u00E1\u0161 k\u013E\u00FA\u010D (alebo najv\u00E4\u010D\u0161\u00ED men\u0161\u00ED alebo najmen\u0161\u00ED v\u00E4\u010D\u0161\u00ED) v koreni.

splaytree = Splay strom

stringology = Stringol\u00F3gia

suffixtree = Sufixov\u00FD strom

suffixtree-found = Ka\u017Ed\u00FD list v tomto podstrome reprezentuje sufix za\u010D\u00EDnaj\u00FAci "#1" a pam\u00E4t\u00E1 si jeho poz\u00EDciu. Na\u0161li sme #2 v\u00FDskytov.

sum = suma

sumimum = S\u00FA\u010Det intervalu je #1.

sxbaftersecondrule = Pokra\u010Dujeme v prip\u00E1jan\u00ED.

sxbcontinue = Za\u010D\u00EDname prid\u00E1va\u0165 p\u00EDsmenko '#1'.

sxbdownwalk = N\u00E1jdeme miesto, kde pripoj\u00EDme p\u00EDsmenko '#1'.

sxbdownwalkedge = Pokra\u010Dujeme v h\u013Eadan\u00ED.

sxbexplicit = Prerob\u00EDme strom na explicitn\u00FA formu.

sxbfind = H\u013Ead\u00E1me re\u0165azec '#1'.

sxbfirstrule = Roz\u0161\u00EDrime vrcholy, ktor\u00E9 spadaj\u00FA do prv\u00E9ho pravidla o p\u00EDsmenko '#1'.

sxbphase = Vstupujeme do #1. f\u00E1zy.

sxbsecondrule = Rozdel\u00EDme hranu a pripoj\u00EDme p\u00EDsmenko '#1'.

sxbslink = Vyu\u017Eijeme suffix link.

sxbstart = Za\u010D\u00EDname vklada\u0165 slovo.

sxbthirdrule = Prv\u00FD kr\u00E1t sa vyskytlo tretie pravidlo. N\u00E1sleduje \u010Fal\u0161ia f\u00E1za.

sxbupwalk = Ideme do najbli\u017E\u0161ieho vrcholu vy\u0161\u0161ie po hrane.

text = Text

treap = Treap

treapbubbledown = Bubleme vrchol nadol, k\u00FDm nemaj\u00FA deti men\u0161iu prioritu.

treapbubbleup = Bubleme vrchol nahor, k\u00FDm otec nem\u00E1 v\u00E4\u010D\u0161iu prioritu.

treapdeletecase1 = Teraz je vrchol list, tak\u017Ee ho vieme jednoducho odstr\u00E1ni\u0165.

trie = P\u00EDsmenkov\u00FD strom

triea = Stringol\u00F3gia

triedelete = Odstr\u00E1\u0148 "#1"

triedeletedbdb = Zma\u017Eeme p\u00EDsmenko.

triedeletedbend = M\u0155tva vetva je zmazan\u00E1.

triedeletefindunsu = Nem\u00F4\u017Eeme predsa zmaza\u0165 slovo, ktor\u00E9 sa v strome nenach\u00E1dza.

triedeletenote1 = V strome najprv mus\u00EDme n\u00E1js\u0165 zadan\u00E9 slovo.

triedeletenote2 = Teraz odstr\u00E1nime zna\u010Dku konca slova a n\u00E1sledne odstr\u00E1nime aj "m\u0155tvu vetvu", tj. v\u0161etky vrcholy, ktor\u00E9 ostali visie\u0165 a nie s\u00FA ukon\u010Den\u00E9 koncom slova.

triedeletewodb = Teraz zma\u017Eeme "m\u0155tve" vrcholy.

triefind = N\u00E1jdi "#1"

triefindending1 = P\u00EDsmenko '#1' nie je pripojen\u00E9 na moment\u00E1lne. Tak\u017Ee, slovo sa v strome nenach\u00E1dza!

triefindending2 = Pre\u010D\u00EDtali sme dan\u00E9 slovo, ale v strome sa \u017Eiadne slovo tu nekon\u010D\u00ED. Tak\u017Ee, dan\u00E9 slovo v strome nenach\u00E1dza!

triefindmovedown = Prejdeme ni\u017E\u0161ie na p\u00EDsmenko '#1'.

triefindnote = Po hran\u00E1ch s p\u00EDsmenkami dan\u00E9ho slova prejdeme strom. Ak pre\u010D\u00EDtame cel\u00E9 slovo a skon\u010D\u00EDme vo vrchole ozna\u010Den\u00FDm, \u017Ee sa tam nejak\u00E9 slovo kon\u010D\u00ED, tak sa slovo v strome nach\u00E1dza. V ka\u017Edom inom pr\u00EDpade sa slovo v strome nenach\u00E1dza.

triefindsucc = Pre\u010D\u00EDtali sme dan\u00E9 slovo a v strome sa tu jedno kon\u010D\u00ED. Tak\u017Ee, dan\u00E9 slovo v strome nach\u00E1dza!

triei = Trie

trieinsert = Vlo\u017E "#1"

trieinserteow = Vlo\u017Eili sme cel\u00E9 slovo. E\u0161te ozna\u010D\u00EDme koniec slova.

trieinsertneow = Slovo sa u\u017E v strome nach\u00E1dza.

trieinsertnote = Rozk\u00FAskujeme slovo na p\u00EDsmenk\u00E1, ktor\u00E9 potom ve\u0161iame jedno pod druh\u00E9. Ak je p\u00EDsmenko zavesen\u00E9, jednoducho do \u0148ho prejdeme a pokra\u010Dujeme.

trieinsertwch = Presunieme sa na p\u00EDsmenko '#1'.

trieinsertwoch = Pripoj\u00EDme p\u00EDsmenko '#1'.

trierootstart = Za\u010D\u00EDname v koreni.

uf-byrank = pod\u013Ea ranku

uf-compresion = kompresia cesty

uf-find-heuristic = Vyh\u013Ead\u00E1vanie:

uf-halving = p\u00F3lenie cesty

uf-none = naivn\u00E9

uf-splitting = delenie cesty

uf-union-heuristic = Sp\u00E1janie:

ufa = Union Find

ufalreadyroot = Tento prvok je z\u00E1stupcom! 

ufcompression = Zjednodu\u0161\u00EDme ozna\u010Den\u00FA cestu.

ufdown = Pokra\u010Dujeme smerom dole.

ufdownson = Z\u00E1stupca u\u017E je pripojen\u00FD.

ufdownstart = Teraz pripoj\u00EDme v\u0161etky elementy, ktor\u00E9 sme stretli po ceste, ku z\u00E1stupcovi.

uffind = H\u013Eadanie z\u00E1stupcu

uffindstart = H\u013Ead\u00E1me z\u00E1stupcu mno\u017Einy obsahuj\u00FAcu element #1.

ufi = Union Find

ufrootfound = Na\u0161li sme z\u00E1stupcu mno\u017Einy. Je to: #1.

ufsameset = Prvky s\u00FA v rovnakej mno\u017Eine, tak\u017Ee m\u00E1me po pr\u00E1ci.

ufunion = Sp\u00E1janie dvoch mno\u017E\u00EDn

ufunionbyrank = Prv\u00FD z\u00E1stupca m\u00E1 rank #1, druh\u00FD m\u00E1 rank #2. Men\u0161\u00ED rank rozhoduje.

ufunionfirstsecond = Preto zaves\u00EDme druh\u00E9ho z\u00E1stupcu pod prv\u00E9ho.

ufunionsamerank = Obaja z\u00E1stupci maj\u00FA rovnak\u00FD rank. Z \u013Eubov\u00F4le sme sa rozhodli pripoji\u0165 druh\u00E9ho z\u00E1stupcu pod prv\u00E9ho. \u010Ealej zv\u00FD\u0161ime rank prv\u00E9mu z\u00E1stupcovi o jeden.

ufunionsecondfirst = Preto zaves\u00EDme prv\u00E9ho z\u00E1stupcu pod  druh\u00E9ho.

ufunionsimple = Teraz napoj\u00EDme druh\u00E9ho reprezentanta pod prv\u00E9ho.

ufup = Postupujeme ku kore\u0148u.

ufupspecial = Pripoj\u00EDme vnuka.

zoomio = Pribl\u00ED\u017E/Oddia\u013E
