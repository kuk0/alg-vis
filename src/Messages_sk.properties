
234tree = 2-3-4 strom

23tree = 2-3 strom

EMPTYSTR = \ 

aaok = Tento vrchol je OK.

aaskew = Skew: \u013Dav\u00FD podstrom m\u00E1 rovnak\u00FD rank; sprav\u00EDme rot\u00E1ciu doprava.

aaskew2 = Skew2: \u013Dav\u00FD podstrom m\u00E1 rovnak\u00FD rank; sprav\u00EDme rot\u00E1ciu doprava.

aaskew3 = Skew3: \u013Dav\u00FD podstrom m\u00E1 rovnak\u00FD rank; sprav\u00EDme rot\u00E1ciu doprava.

aasplit = Split: Pseudovrchol (tvoren\u00FD susedn\u00FDmi vrcholmi s rovnak\u00FDm rankom) je pr\u00EDli\u017E ve\u013Ek\u00FD; sprav\u00EDme rot\u00E1ciu v\u013Eavo a zv\u00FD\u0161ime rank stredn\u00E9ho vrcholu.

aasplit2 = Split2: Pseudovrchol (tvoren\u00FD susedn\u00FDmi vrcholmi s rovnak\u00FDm rankom) je pr\u00EDli\u017E ve\u013Ek\u00FD; sprav\u00EDme rot\u00E1ciu v\u013Eavo a zv\u00FD\u0161ime rank stredn\u00E9ho vrcholu.

aatree = AA strom

activeheap = Akt\u00EDvna halda:

alreadythere = Dan\u00FD k\u013E\u00FA\u010D sa u\u017E nach\u00E1dza v strome.

avedepth = Priem. h\u013Abka

avldeletebal = Pr\u00E1ve sme vymazali vrchol; vraciame sa sp\u00E4\u0165 ku kore\u0148u a upravujeme inform\u00E1cie o vyv\u00E1\u017Eenosti.

avlinsertbal = Pr\u00E1ve sme vlo\u017Eili nov\u00FD vrchol; vraciame sa sp\u00E4\u0165 ku kore\u0148u a upravujeme inform\u00E1cie o vyv\u00E1\u017Eenosti.

avll = Prav\u00FD podstrom je pr\u00EDli\u0161 vysok\u00FD: rotujeme do\u013Eava.

avllr = Prav\u00FD podstrom je pr\u00EDli\u0161 vysok\u00FD, ale jeho \u013Eav\u00FD podstrom je vy\u0161\u0161\u00ED ako prav\u00FD: rotujeme najsk\u00F4r do\u013Eava, potom doprava.

avlr = \u013Dav\u00FD podstrom je pr\u00EDli\u0161 vysok\u00FD: rotujeme doprava.

avlrl = \u013Dav\u00FD podstrom je pr\u00EDli\u0161 vysok\u00FD, ale jeho prav\u00FD podstrom je vy\u0161\u0161\u00ED ako \u013Eav\u00FD: rotujeme najsk\u00F4r doprava, potom do\u013Eava.

avltree = AVL strom

avlupdatebal = Uprav\u00EDme inform\u00E1ciu o vyv\u00E1\u017Eenosti.

bdelete1 = Pr\u00EDpad I: K\u013E\u00FA\u010D je v liste, m\u00F4\u017Eeme ho odstr\u00E1ni\u0165.

bdelete2 = Pr\u00EDpad II: K\u013E\u00FA\u010D je v internom vrchole; nahrad\u00EDme ho jeho nasledovn\u00EDkom.

bfind = #1 &lt; #2 &lt; #3, ideme po #4. hrane.

bfind0 = #1 &lt; #2, ideme po 1. hrane.

bfindn = #1 &lt; #2, ideme po #3. hrane.

binheap = Binomi\u00E1lna halda

binsertleaf = K\u013E\u00FA\u010D vlo\u017E\u00EDme do tohto vrcholu.

bleft = Pr\u00EDpad I: Vrchol je pr\u00EDli\u017E mal\u00FD, ale jeho \u013Eav\u00FD brat je dos\u0165 ve\u013Ek\u00FD, tak\u017Ee si od neho m\u00F4\u017Eeme jeden k\u013E\u00FA\u010D zobra\u0165.

bmerge = Pr\u00EDpad III: Vrchol aj jeho bratia s\u00FA pr\u00EDli\u017E mal\u00ED, tak\u017Ee ich spoj\u00EDme.

bright = Pr\u00EDpad II: Vrchol je pr\u00EDli\u017E mal\u00FD, ale jeho prav\u00FD brat je dos\u0165 ve\u013Ek\u00FD, tak\u017Ee si od neho m\u00F4\u017Eeme jeden k\u013E\u00FA\u010D zobra\u0165.

bsplit = Vrchol je pr\u00EDli\u017E ve\u013Ek\u00FD, mus\u00EDme ho rozdeli\u0165.

bst = Bin\u00E1rny vyh\u013Ead\u00E1vac\u00ED strom

bst-delete-case1 = Pr\u00EDpad I: Vrchol je list, tak\u017Ee ho m\u00F4\u017Eeme jednoducho odstr\u00E1ni\u0165.

bst-delete-case2 = Pr\u00EDpad II: Vrchol m\u00E1 iba jedn\u00E9ho syna.

bst-delete-case3 = Pr\u00EDpad III: Vrchol #1 m\u00E1 oboch synov. V tomto pr\u00EDpade n\u00E1jdeme jeho nasledovn\u00EDka, ktor\u00FDm ho nahrad\u00EDme. Nasledovn\u00EDk je naj\u013Eavej\u0161\u00ED vrchol v pravom podstrome. M\u00E1 najviac jedn\u00E9ho syna (prav\u00E9ho) a teda ho vieme jednoducho odstr\u00E1ni\u0165.

bst-delete-go-left = Cho\u010F v\u013Eavo.

bst-delete-linkpar = Vrchol #1 odstr\u00E1nime, pri\u010Dom #2 zaves\u00EDme pod jeho star\u00E9ho otca #3.

bst-delete-newroot = Vrchol #1 odstr\u00E1nime. Jeho syn #2 sa stane nov\u00FDm kore\u0148om.

bst-delete-replace = Vrchol #1 vymen\u00EDme za #2 a #1 odstr\u00E1nime.

bst-delete-succ = Vrchol #2 je nasledovn\u00EDkom #1 (\u017Eiadny prvok v strome nie je medzi #1 a #2). Ke\u010F\u017Ee #2 nem\u00E1 \u013Eav\u00E9ho syna, vieme ju jednoducho odpoji\u0165.

bst-delete-succ-link = Odpoj\u00EDme nasledovn\u00EDka, pri\u010Dom vrchol #1 napoj\u00EDme pod #2.

bst-delete-succ-start = Za\u010Dneme v koreni prav\u00E9ho podstromu.

bst-delete-succ-unlink = Nasledovn\u00EDka jednoducho odpoj\u00EDme.

bst-delete-unlink = Vrchol jednoducho odpoj\u00EDme.

bst-insert-left = Ke\u010F\u017Ee #1 &lt; #2, vklad\u00E1me do \u013Eav\u00E9ho podstromu.

bst-insert-right = Ke\u010F\u017Ee #1 &gt; #2, vklad\u00E1me do prav\u00E9ho podstromu.

bst-insert-start = Za\u010Dneme v koreni.

bstdeletestart = Najsk\u00F4r mus\u00EDme n\u00E1js\u0165 vrchol s dan\u00FDm k\u013E\u00FA\u010Dom.

bstfindleft = Ke\u010F\u017Ee #1 &lt; #2, h\u013Ead\u00E1me v \u013Eavom podstrome.

bstfindright = Ke\u010F\u017Ee #1 &gt; #2, h\u013Ead\u00E1me v pravom podstrome.

bstfindstart = Za\u010Dneme h\u013Eada\u0165 v koreni.

btree = B strom

btreeorder = R\u00E1d B stromu:

button-clear = Zma\u017E

button-decreasekey = Zn\u00ED\u017E hodnotu

button-delete = Odstr\u00E1\u0148

button-deletemax = Odstr\u00E1\u0148 maximum

button-deletemin = Odstr\u00E1\u0148 minimum

button-find = H\u013Eadaj

button-increasekey = Zv\u00FD\u0161 hodnotu

button-insert = Vlo\u017E

button-makeset = Pridaj prvky

button-meld = Zl\u00FA\u010D

button-pause = Pauzy

button-random = N\u00E1hodn\u00E9

button-random-unions = Spoj n\u00E1hodn\u00E9 prvky

button-save = Ulo\u017Ei\u0165

button-uffind = N\u00E1jdi

button-union = Spoj

control = Ovl\u00E1danie

datastructures = D\u00E1tov\u00E9 \u0161trukt\u00FAry

decreasekey = Zn\u00ED\u017Eenie hodnoty

delete = Odstr\u00E1\u0148 "#1"

deleted = Vymazan\u00FDch

deletion = Odstra\u0148ovanie

dictionary = Slovn\u00EDky

display = Display

done = Hotovo.

empty = Strom je pr\u00E1zdny.

emptyheap = pr\u00E1zdna halda

excess = Vrcholov navy\u0161e

fibheap = Fibonacciho halda

find = H\u013Eadaj "#1"

found = N\u00E1jden\u00E9.

full = pln\u00E9

fullheap = pln\u00E1

gbdeletedeleted = Vrchol u\u017E je ozna\u010Den\u00FD na vymazanie.

gbdeletemark = Vrchol ozna\u010D\u00EDme na vymazanie (naozaj ho odstr\u00E1nime a\u017E pri najbli\u017E\u0161om prebudovan\u00ED stromu).

gbdeleterebuild = Polovica vrcholov u\u017E je ozna\u010Den\u00E1 na vymazanie. Cel\u00FD strom prebudujeme.

gbfinddeleted = Vrchol je ozna\u010Den\u00FD na vymazanie. Nen\u00E1jden\u00E9.

gbinsertunmark = K\u013E\u00FA\u010D u\u017E je v strome, ale ozna\u010Den\u00FD na vymazanie. Iba zru\u0161\u00EDme zna\u010Dku.

gbrebuild1 = F\u00E1za I: Transformujeme podstrom na "prav\u00FA re\u0165az" a odstra\u0148ujeme vrcholy ozna\u010Den\u00E9 na vymazanie.

gbrebuild2 = F\u00E1za II: Re\u0165az transformujeme na dokonale vyv\u00E1\u017Een\u00FD strom.

gbtoohigh = Tento podstrom je pr\u00EDli\u0161 vysok\u00FD, cel\u00FD ho prebudujeme.

heap = Halda

heapempty = Halda je pr\u00E1zdna.

heapfull = Halda je pln\u00E1.

height = V\u00FD\u0161ka

increasekey = Zv\u00FD\u0161enie hodnoty

insert = Vlo\u017E "#1"

insertion = Vkladanie

keys = K\u013E\u00FA\u010Dov

language = Language

layout = Layout

layout-compact = Kompaktn\u00FD

layout-simple = Jednoduch\u00FD

lazybinheap = Leniv\u00E1 binomi\u00E1lna halda

max = max

maxheap = Max Halda

maxheapbubbledown = Prebubleme vrchol nadol (vymie\u0148ame v\u017Edy s v\u00E4\u010D\u0161\u00EDm synom, k\u00FDm nemaj\u00FA obaja synovia men\u0161iu prioritu).

maxheapbubbleup = Prebubleme vrchol nahor (t.j. vymie\u0148ame s otcom, k\u00FDm nem\u00E1 otec v\u00E4\u010D\u0161iu prioritu).

meldable-pq = Zl\u00FA\u010Dite\u013En\u00E9 prioritn\u00E9 fronty

min = min

minheap = Min Halda

minheapbubbledown = Prebubleme vrchol nadol (vymie\u0148ame v\u017Edy s men\u0161\u00EDm synom, k\u00FDm nemaj\u00FA obaja synovia v\u00E4\u010D\u0161iu prioritu).

minheapbubbleup = Prebubleme vrchol nahor (t.j. vymie\u0148ame s otcom, k\u00FDm nem\u00E1 otec men\u0161iu prioritu).

mode23 = S\u00FAvis s 2-3 stromami

mode234 = S\u00FAvis s 2-3-4 stromami

newroot = Ke\u010F\u017Ee je strom pr\u00E1zdny, vytvor\u00EDme nov\u00FD kore\u0148.

next = \u010Ealej

nodes = Vrcholov

notfound = Nen\u00E1jden\u00E9.

opt = opt

pq = Prioritn\u00E9 fronty

previous = Sp\u00E4\u0165

rbdelete1 = Pr\u00EDpad I: \u010Derven\u00FD s\u00FArodenec: Vymen\u00EDme farby otca a prav\u00E9ho s\u00FArodenca a zrotujeme s\u00FArodenca; dostaneme tak pr\u00EDpad II, III, alebo IV.

rbdelete2 = Pr\u00EDpad II, s\u00FArodenec a obe jeho deti s\u00FA \u010Dierne: the extra black is moved up the tree.

rbdelete3 = Pr\u00EDpad III, s\u00FArodenec a jeho "vonkaj\u0161\u00ED" syn s\u00FA \u010Dierni, jeho "vn\u00FAtorn\u00FD" syn je \u010Derven\u00FD: Prevedieme na pr\u00EDpad IV.

rbdelete4 = Pr\u00EDpad IV, s\u00FArodenec a jeho "vn\u00FAtorn\u00FD" syn s\u00FA \u010Dierni, jeho "vonkaj\u0161\u00ED" syn je \u010Derven\u00FD: Vymen\u00EDme farby otca a s\u00FArodenca, zrotujeme ho a jeho \u010Derven\u00E9ho syna zafarb\u00EDme na \u010Dierno.

rbinsertcase1 = Pr\u00EDpad I, \u010Derven\u00FD str\u00FDko: Prefarb\u00EDme otca a str\u00FDka na \u010Dierno, star\u00E9ho otca na \u010Derveno a pokra\u010Dujeme star\u00FDm otcom.

rbinsertcase2 = Pr\u00EDpad II, \u010Dierny str\u00FDko, "vn\u00FAtorn\u00FD vrchol": prevedieme na pr\u00EDpad III.

rbinsertcase3 = Pr\u00EDpad III, \u010Dierny str\u00FDko, "vonkaj\u0161\u00ED vrchol": Zrotujeme a prefarb\u00EDme vrcholy.

redblack = \u010Cerveno-\u010Dierny strom

rotate = Rotuj

rotations = Rot\u00E1cie

scapegoat = GB strom

search = H\u013Eadanie

show-order = Uk\u00E1\u017E poradie

show-subtrees = Uk\u00E1\u017E podstromy

size = Ve\u013Ekos\u0165

skipdelete = N\u00E1jden\u00FD vrchol vyma\u017Eeme z ka\u017Edej \u00FArovne.

skipdown = Nasledovn\u00FD vrcrhol je v\u00E4\u010D\u0161\u00ED alebo rovn\u00FD n\u00E1\u0161mu. Ideme dolu.

skipend = Hodili sme si mincou. Padol znak, tak\u017Ee kon\u010D\u00EDme.

skipfindstart = Za\u010Dneme h\u013Eada\u0165 v \u013Eavom hornom rohu.

skipinsertafter = Nov\u00FD vrchol vlo\u017E\u00EDme hne\u010F za tento.

skipinsertnext = Nasleduj\u00FAci vrchol je men\u0161\u00ED ako n\u00E1\u0161. Vklad\u00E1me vpravo.

skipinsertstart = Za\u010Dneme v \u013Eavom hornom rohu a n\u00E1jdeme spr\u00E1vne miesto, kam vlo\u017Ei\u0165 nov\u00FD vrchol.

skiplist = Skiplist

skipnext = Nasledovn\u00FD vrchol je men\u0161\u00ED ako n\u00E1\u0161. Ideme vpravo.

skippromote = Hodili sme si mincou. Padla hlava, tak\u017Ee prid\u00E1me \u010Fal\u0161\u00ED vrchol.

splay = Splay-ovanie

splaydelete = Odstr\u00E1nime kore\u0148 a vysplayujeme minimum prav\u00E9ho podstromu.

splaydeleteleft = Kore\u0148 nem\u00E1 prav\u00E9ho syna; jednoducho ho odstr\u00E1nime a z \u013Eav\u00E9ho syna sprav\u00EDme nov\u00FD kore\u0148.

splaydeletelink = Minimum bude teraz nov\u00FD kore\u0148; ke\u010F\u017Ee minimum nem\u00E1 \u013Eav\u00E9ho syna, sta\u010D\u00ED prilinkova\u0165 \u013Eav\u00FD podstrom k nov\u00E9mu kore\u0148u.

splaydeleteright = Kore\u0148 nem\u00E1 \u013Eav\u00E9ho syna; jednoducho ho odstr\u00E1nime a z prav\u00E9ho syna sprav\u00EDme nov\u00FD kore\u0148.

splayfound = Tento kore\u0148 budeme splayova\u0165.

splayinroot = Teraz je n\u00E1\u0161 k\u013E\u00FA\u010D (alebo najv\u00E4\u010D\u0161\u00ED men\u0161\u00ED alebo najmen\u0161\u00ED v\u00E4\u010D\u0161\u00ED) v koreni.

splayinsertleft = Kore\u0148 a cel\u00FD \u013Eav\u00FD podstrom je men\u0161\u00ED ako n\u00E1\u0161 k\u013E\u00FA\u010D a cel\u00FD prav\u00FD podstrom je v\u00E4\u010D\u0161\u00ED ako n\u00E1\u0161 k\u013E\u00FA\u010D: jednoducho vytvor\u00EDme nov\u00FD kore\u0148 a pripoj\u00EDme star\u00FD kore\u0148 v\u013Eavo a jeho prav\u00FD podstrom vpravo.

splayinsertright = Kore\u0148 a cel\u00FD prav\u00FD podstrom je v\u00E4\u010D\u0161\u00ED ako n\u00E1\u0161 k\u013E\u00FA\u010D a cel\u00FD \u013Eav\u00FD podstrom je men\u0161\u00ED ako n\u00E1\u0161 k\u013E\u00FA\u010D: jednoducho vytvor\u00EDme nov\u00FD kore\u0148 a pripoj\u00EDme star\u00FD kore\u0148 vpravo a jeho \u013Eav\u00FD podstrom v\u013Eavo.

splayroot = Vrchol nem\u00E1 star\u00E9ho otca; sprav\u00EDme iba jednu rot\u00E1ciu.

splaystart = Najsk\u00F4r n\u00E1jdeme dan\u00FD k\u013E\u00FA\u010D, alebo najmen\u0161\u00ED v\u00E4\u010D\u0161\u00ED, alebo najv\u00E4\u010D\u0161\u00ED men\u0161\u00ED k\u013E\u00FA\u010D a vysplayujeme ho do kore\u0148a.

splaytree = Splay strom

splayzigzagleft = Pr\u00EDpad "Cik-cak" (otec je smerom vpravo a star\u00FD otec smerom v\u013Eavo): vrchol dvakr\u00E1t zrotujeme.

splayzigzagright = Pr\u00EDpad "Cik-cak" (otec je smerom v\u013Eavo a star\u00FD otec smerom vpravo): vrchol dvakr\u00E1t zrotujeme.

splayzigzigleft = Pr\u00EDpad "Cik-cik" (otec aj star\u00FD otec s\u00FA smerom vpravo): najsk\u00F4r zrotujeme otca, potom dan\u00FD vrchol.

splayzigzigright = Pr\u00EDpad "Cik-cik" (otec aj star\u00FD otec s\u00FA smerom v\u013Eavo): najsk\u00F4r zrotujeme otca, potom dan\u00FD vrchol.

text = Text

treap = Treap

treapbubbledown = Bubleme vrchol nadol, k\u00FDm nemaj\u00FA deti men\u0161iu prioritu.

treapbubbleup = Bubleme vrchol nahor, k\u00FDm otec nem\u00E1 v\u00E4\u010D\u0161iu prioritu.

treapdeletecase1 = Teraz je vrchol list, tak\u017Ee ho vieme jednoducho odstr\u00E1ni\u0165.

triea = Trie

triei = Trie

uf-byrank = pod\u013Ea ranku

uf-compresion = kompresia cesty

uf-find-heuristic = Vyh\u013Ead\u00E1vanie:

uf-halving = p\u00F3lenie cesty

uf-none = naivn\u00E9

uf-splitting = delenie cesty

uf-union-heuristic = Sp\u00E1janie:

ufa = Union Find

ufalreadyroot = Tento prvok je z\u00E1stupcom! 

ufcompression = Zjednodu\u0161\u00EDme ozna\u010Den\u00FA cestu.

ufdown = Pokra\u010Dujeme smerom dole.

ufdownson = Z\u00E1stupca u\u017E je pripojen\u00FD.

ufdownstart = Teraz pripoj\u00EDme v\u0161etky elementy, ktor\u00E9 sme stretli po ceste, ku z\u00E1stupcovi.

uffind = H\u013Eadanie z\u00E1stupcu

uffindstart = H\u013Ead\u00E1me z\u00E1stupcu mno\u017Einy obsahuj\u00FAcu element #1.

ufi = Union Find

ufrootfound = Na\u0161li sme z\u00E1stupcu mno\u017Einy. Je to: #1.

ufsameset = Prvky s\u00FA v rovnakej mno\u017Eine, tak\u017Ee m\u00E1me po pr\u00E1ci.

ufunion = Sp\u00E1janie dvoch mno\u017E\u00EDn

ufunionbyrank = Prv\u00FD z\u00E1stupca m\u00E1 rank #1, druh\u00FD m\u00E1 rank #2. Men\u0161\u00ED rank rozhoduje.

ufunionfirstsecond = Preto zaves\u00EDme druh\u00E9ho z\u00E1stupcu pod prv\u00E9ho.

ufunionsamerank = Obaja z\u00E1stupci maj\u00FA rovnak\u00FD rank. Z \u013Eubov\u00F4le sme sa rozhodli pripoji\u0165 druh\u00E9ho z\u00E1stupcu pod prv\u00E9ho. \u010Falej zv\u00FD\u0161ime rank prv\u00E9mu z\u00E1stupcovi o jeden.

ufunionsecondfirst = Preto zaves\u00EDme prv\u00E9ho z\u00E1stupcu pod  druh\u00E9ho.

ufunionsimple = Teraz napoj\u00EDme druh\u00E9ho reprezentanta pod prv\u00E9ho.

ufup = Postupujeme ku kore\u0148u.

ufupspecial = Pripoj\u00EDme vnuka.

zoomio = Pribl\u00ED\u017E/Oddia\u013E
